<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://niyoh120.github.io</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://niyoh120.github.io</link></image><lastBuildDate>Tue, 11 Jun 2024 08:38:27 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>理解Python的生成器</title><link>https://niyoh120.github.io/post/li-jie-Python-de-sheng-cheng-qi.html</link><description>定义一个生成器的方法&#13;
&#13;
- 定义一个含有`yield`语句的函数&#13;
- 定义一个实现了`__iter___`方法（迭代器协议），方法中含有yield语句的类&#13;
&#13;
通过内置的`next`函数和生成器的`send`方法，可以实现调用者与生成器之间的通信和控制流转移&#13;
&#13;
``` python&#13;
def gen():&#13;
    print('in gen')&#13;
    v = yield&#13;
    print('recv {}'.format(v))&#13;
    while True:&#13;
        print('yield {}'.format(v + 100))&#13;
        v = yield v + 100&#13;
        print('recv {}'.format(v))&#13;
&#13;
g = gen()&#13;
next(g) # 等于调用gen.send(None)&#13;
# in gen&#13;
v = g.send(1)&#13;
# recv 1&#13;
# yield 101&#13;
print(v)&#13;
# 101&#13;
v = g.send(2)&#13;
# recv 2&#13;
# yield 102&#13;
print(v)&#13;
# 102&#13;
&#13;
```&#13;
&#13;
首次调用`next`函数或生成器的`send`方法时，生成器会执行到第一个`yield`语句处然后返回，返回值为`yield`后跟的表达式的值，注意首次若是调用send方法，则传入的参数必须是`None`，否则会抛出异常`TypeError: can't send non-None value to a just-started generator`。</description><guid isPermaLink="true">https://niyoh120.github.io/post/li-jie-Python-de-sheng-cheng-qi.html</guid><pubDate>Tue, 11 Jun 2024 08:37:57 +0000</pubDate></item><item><title>理解Python的装饰器</title><link>https://niyoh120.github.io/post/li-jie-Python-de-zhuang-shi-qi.html</link><description>&#13;
```python&#13;
@decorator&#13;
def foo():&#13;
	pass&#13;
```&#13;
&#13;
实际上等于 `foo=decorator(foo)` &#13;
&#13;
装饰器的返回值应该是一个`callable`&#13;
&#13;
```python&#13;
def decorator(func):&#13;
    def warp(*args,**kw):&#13;
        print('in decorator')&#13;
        return func(*args,*kw)&#13;
    return warp&#13;
&#13;
@decorator&#13;
def foo():&#13;
    print('in foo')&#13;
&#13;
foo()&#13;
&#13;
# in decorator&#13;
# in foo&#13;
```&#13;
&#13;
`foo=decorator(foo)`执行于`foo`的定义完成时（python中函数定义也是一种语句）&#13;
&#13;
利用装饰器可以很方便的实现闭包，闭包可以理解为具有上下文的函数&#13;
&#13;
```python&#13;
def print_message(msg):&#13;
    def closeure(func):&#13;
        def wrap(*args, **kw):&#13;
            print(msg)&#13;
            return func(*args, **kw)&#13;
&#13;
        return wrap&#13;
&#13;
    return closeure&#13;
&#13;
@print_message('msg1')&#13;
def foo1():&#13;
    pass&#13;
&#13;
@print_message('msg2')&#13;
def foo2():&#13;
    pass&#13;
&#13;
foo1() # msg1&#13;
foo2() # msg2&#13;
```&#13;
&#13;
装饰器可以嵌套，注意执行顺序是装饰器的使用顺序&#13;
&#13;
```python&#13;
def print_message(msg):&#13;
    def closeure(func):&#13;
        def wrap(*args, **kw):&#13;
            print(msg)&#13;
            return func(*args, **kw)&#13;
&#13;
        return wrap&#13;
&#13;
    return closeure&#13;
&#13;
@print_message('msg1')&#13;
@print_message('msg2')&#13;
def foo1():&#13;
    pass&#13;
&#13;
@print_message('msg2')&#13;
@print_message('msg1')&#13;
def foo2():&#13;
    pass&#13;
&#13;
foo1()&#13;
&#13;
# msg1&#13;
# msg2&#13;
&#13;
foo2()&#13;
&#13;
# msg2&#13;
# msg1&#13;
```&#13;
&#13;
因为装饰器实际上是语法糖，所以有一个问题，装饰器返回的函数并不是原本的函数，原本的函数的一些属性（如文档字符串）可能会丢失.&#13;
&#13;
解决方法是使用`functools.wraps`，它会将原来函数的属性复制到装饰器返回的函数中.&#13;
&#13;
```python&#13;
from functools import wraps&#13;
&#13;
def my_decorator(f):&#13;
    @wraps(f)&#13;
    def wrapper(*args, **kw):&#13;
        print('Calling decorated function')&#13;
        return f(*args, **kw)&#13;
&#13;
    return wrapper&#13;
&#13;
@my_decorator&#13;
def example():&#13;
    '''Docstring'''&#13;
    print('Called example function')&#13;
&#13;
example()  # Calling decorated functionCalled example function&#13;
example.__name__  # 'example'&#13;
example.__doc__  # 'Docstring'&#13;
```&#13;
。</description><guid isPermaLink="true">https://niyoh120.github.io/post/li-jie-Python-de-zhuang-shi-qi.html</guid><pubDate>Tue, 11 Jun 2024 07:58:52 +0000</pubDate></item></channel></rss>