<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Blog Title</title><link>https://niyoh120.github.io</link><description>Blog description</description><copyright>Blog Title</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://niyoh120.github.io</link></image><lastBuildDate>Tue, 11 Jun 2024 16:24:17 +0000</lastBuildDate><managingEditor>Blog Title</managingEditor><ttl>60</ttl><webMaster>Blog Title</webMaster><item><title>Rust 基础</title><link>https://niyoh120.github.io/post/Rust%20-ji-chu.html</link><description>## 类型&#13;
&#13;
### 变量&#13;
&#13;
变量使用let定义，常量使用const定义，变量默认是immutable的，如果需要声明一个mutable的变量，使用let mut&#13;
&#13;
可以多次使用let定义名字相同的变量（变量的类型可以不同），后定义的变量会遮蔽掉前一个变量，以减少取名的麻烦&#13;
&#13;
编译器在大部分情况下会根据上下文自动推倒变量的类型，但在有可能出现二义性的情况下，必须显式声明变量的类型，`let v:T`，可以声明部分类型，让编译器去推导剩下的类型&#13;
&#13;
数字类型有i8,i16,i32,i64,isize，及对应的无符号类型，u前缀，一般使用i32或u32，索引使用usize&#13;
&#13;
### 类型别名&#13;
&#13;
```&#13;
type Age = u32;//可以是泛型type Double&lt;T&gt; = (T,Vec&lt;T&gt;)&#13;
```&#13;
&#13;
### 全局变量&#13;
&#13;
用static关键字声明，生命周期是’staitc，是整个程序执行期间&#13;
&#13;
- 全局变量必须在声明的时候马上初始化&#13;
- 全局变量的初始化值必须是编译期可确定的常量，不能包括运行时才能确定的表达式、语句和函数调用(const fn是可以的)&#13;
- 带有mut修饰的全局变量，在使用的时候必须使用unsafe关键字&#13;
&#13;
### 常量&#13;
&#13;
用const声明,不是变量,初始化的值必须是编译期常量,没有模式匹配的效果&#13;
&#13;
## 基本数据类型&#13;
&#13;
### tuple和array&#13;
&#13;
可以通过pattern match解构元组，也可以使用t.index来访问其中的元素，如t.0,t.1&#13;
&#13;
array的长度是固定的，越界访问会panic&#13;
&#13;
### 函数&#13;
&#13;
函数的定义&#13;
&#13;
```&#13;
fn function&lt;'a,T&gt;(x:&amp;'a T)-&gt;&amp;'a T{}&#13;
```&#13;
&#13;
参数的类型必须显式声明&#13;
&#13;
### 语句(statement)和表达式(expression)的区别&#13;
&#13;
语句是一条指令，实现一个动作，以分号结尾，没有结果值 表达式求值得出一个结果值 表达式和语句的区分是Rust和一些语言（如C）的区别之一&#13;
&#13;
函数由一系列语句和可选的表示返回值的表达式组成&#13;
&#13;
### Struct&#13;
&#13;
```&#13;
//可以定义一个tuple structstruct Foo(i32,i32);//然后这样使用let foo = Foo(42,49);println!('{}.{}',foo.0,foo.1);&#13;
```&#13;
&#13;
### 循环&#13;
&#13;
```&#13;
    while C{      }    loop{ //无限循环    }    for E in C{    }&#13;
```&#13;
&#13;
```&#13;
fn main() {    //Like range in python    for i in 1..4 {        println!('{}!', i);    }    println!('done!');}&#13;
```&#13;
&#13;
### ref 和 &amp;&#13;
&#13;
```&#13;
// 下面两行是等价的,a的类型都是&amp;i32,一般情况下都用&amp;，具体看http://xion.io/post/code/rust-patterns-ref.htmllet ref a = 2;let a = &amp;2;&#13;
```&#13;
&#13;
要理解两者的区别，需要理解什么是模式匹配，&amp;会成为模式的一部分，ref不会，所以&#13;
&#13;
```&#13;
fn main() {    let s = String::from('hello');    // let &amp;sf = &amp;s; 这句不能通过编译，sf的类型推导为String，sf会通过&amp;s取得s的所有权，无法通过brrow check    let ref sf = &amp;s; //可以编译，ref不影响pattern，sf的类型为 &amp;&amp;s}&#13;
```&#13;
&#13;
引用类型要配合生命周期使用&#13;
&#13;
### 模式匹配&#13;
&#13;
看[[这篇文章](http://xion.io/post/code/rust-patterns-ref.html)](http://xion.io/post/code/rust-patterns-ref.html)&#13;
&#13;
### 模块化&#13;
&#13;
每个文件作为一个模块，或者文件夹为模块名，其中的mod.rs为模块入口，or mod’s namespace in single file. mod can be nested&#13;
&#13;
### case need to annotate types annotate&#13;
&#13;
use `collect` to return a container&#13;
&#13;
### closure&#13;
&#13;
infer capture value according to function use in closure, priority is &amp;T, &amp;mut T and T Using move before vertical pipes forces closure to take ownership of captured variables&#13;
&#13;
the compiler will capture variables in the least restrictive manner possible. For instance, consider a parameter annotated as FnOnce. This specifies that the closure may capture by &amp;T, &amp;mut T or T, but the compiler will ultimately choose based on how the captured variables are used in the closure. 换句话说，每个closure至少都会实现FnOnce(表示最多可调用一次），call方法的第一个参数为self，如果该closure最多只有对外部环境的&amp;mut访问，则会增加实现FnMut，call方法的第一个参数为&amp;mut sefl，如果只有对外部环境的&amp;访问，则实现Fn,表示该函数可重复调用且无副作用（也就是纯函数）,call方法的第一个参数为&amp;self&#13;
&#13;
Fn系列trait包含函数参数和返回值，比如FnOnce(E)-&gt;F 表示接收E类型的参数返回F类型的可调用一次的函数,FnOnce()表示函数没有参数也没有返回值&#13;
&#13;
接受一个匿名函数为参数的函数必须声明泛型参数，调用时编译器会根据传入的匿名函数类型自动推导该参数&#13;
&#13;
Diverging functions never return. They are marked using !, which is an empty type.&#13;
&#13;
### Associated types&#13;
&#13;
[[看这篇文章的](https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html)](https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html)&#13;
&#13;
### 迭代器&#13;
&#13;
调用next方法返回Option，结尾处返回None 迭代器本身是mutable的，不需要显式声明，因此只能使用一次 iter返回的是元素的inmutable reference iter_mut返回mutable reference into_iter move ownership to return value 迭代器的某些方法会消费这个迭代器（转移这个迭代器的所有权），比如sum方法，调用这类方法后迭代器就无效了（类似值被移走了） 另一些方法称作迭代器适配器，比如map，将某一函数作用在迭代器的所有元素上，这些函数是lazy的，需要在最后调用consumed方法才会执行，比如collent方法&#13;
&#13;
实现 Iterator trait只需要实现next方法&#13;
&#13;
### 智能指针&#13;
&#13;
四种智能指针&#13;
&#13;
- `Box&lt;T&gt;` 对应C++中的`unique_ptr`&#13;
- `Rc&lt;T&gt;`和`RefCell&lt;T&gt;`对应C++中的`shared_ptr`，区别是前者只能返回inmutable引用，后者可以返回inmutable或mutable引用&#13;
- `Weak&lt;T&gt;`对应C++中的`weak_ptr`&#13;
- `Arc&lt;T&gt;`是线程安全的`RC&lt;T&gt;`(Atomically Reference Counted)，只能返回immutable引用，如果需要修改状态，可以在其中装`Mutex`,`Rwlock`或者原子类型。</description><guid isPermaLink="true">https://niyoh120.github.io/post/Rust%20-ji-chu.html</guid><pubDate>Tue, 11 Jun 2024 08:43:40 +0000</pubDate></item><item><title>简单的笔记本电脑选购指南</title><link>https://niyoh120.github.io/post/jian-dan-de-bi-ji-ben-dian-nao-xuan-gou-zhi-nan.html</link><description>## 基本守则&#13;
&#13;
- 不要去电脑城或任何非官方授权的实体店&#13;
- 买前到网上搜索相关评测，或到笔记本吧、知乎等社区提问，避免踩坑。</description><guid isPermaLink="true">https://niyoh120.github.io/post/jian-dan-de-bi-ji-ben-dian-nao-xuan-gou-zhi-nan.html</guid><pubDate>Tue, 11 Jun 2024 08:40:30 +0000</pubDate></item><item><title>理解Python的生成器</title><link>https://niyoh120.github.io/post/li-jie-Python-de-sheng-cheng-qi.html</link><description>定义一个生成器的方法&#13;
&#13;
- 定义一个含有`yield`语句的函数&#13;
- 定义一个实现了`__iter___`方法（迭代器协议），方法中含有yield语句的类&#13;
&#13;
通过内置的`next`函数和生成器的`send`方法，可以实现调用者与生成器之间的通信和控制流转移&#13;
&#13;
``` python&#13;
def gen():&#13;
    print('in gen')&#13;
    v = yield&#13;
    print('recv {}'.format(v))&#13;
    while True:&#13;
        print('yield {}'.format(v + 100))&#13;
        v = yield v + 100&#13;
        print('recv {}'.format(v))&#13;
&#13;
g = gen()&#13;
next(g) # 等于调用gen.send(None)&#13;
# in gen&#13;
v = g.send(1)&#13;
# recv 1&#13;
# yield 101&#13;
print(v)&#13;
# 101&#13;
v = g.send(2)&#13;
# recv 2&#13;
# yield 102&#13;
print(v)&#13;
# 102&#13;
&#13;
```&#13;
&#13;
首次调用`next`函数或生成器的`send`方法时，生成器会执行到第一个`yield`语句处然后返回，返回值为`yield`后跟的表达式的值，注意首次若是调用send方法，则传入的参数必须是`None`，否则会抛出异常`TypeError: can't send non-None value to a just-started generator`。</description><guid isPermaLink="true">https://niyoh120.github.io/post/li-jie-Python-de-sheng-cheng-qi.html</guid><pubDate>Tue, 11 Jun 2024 08:37:57 +0000</pubDate></item><item><title>理解Python的装饰器</title><link>https://niyoh120.github.io/post/li-jie-Python-de-zhuang-shi-qi.html</link><description>&#13;
```python&#13;
@decorator&#13;
def foo():&#13;
	pass&#13;
```&#13;
&#13;
实际上等于 `foo=decorator(foo)` &#13;
&#13;
装饰器的返回值应该是一个`callable`&#13;
&#13;
```python&#13;
def decorator(func):&#13;
    def warp(*args,**kw):&#13;
        print('in decorator')&#13;
        return func(*args,*kw)&#13;
    return warp&#13;
&#13;
@decorator&#13;
def foo():&#13;
    print('in foo')&#13;
&#13;
foo()&#13;
&#13;
# in decorator&#13;
# in foo&#13;
```&#13;
&#13;
`foo=decorator(foo)`执行于`foo`的定义完成时（python中函数定义也是一种语句）&#13;
&#13;
利用装饰器可以很方便的实现闭包，闭包可以理解为具有上下文的函数&#13;
&#13;
```python&#13;
def print_message(msg):&#13;
    def closeure(func):&#13;
        def wrap(*args, **kw):&#13;
            print(msg)&#13;
            return func(*args, **kw)&#13;
&#13;
        return wrap&#13;
&#13;
    return closeure&#13;
&#13;
@print_message('msg1')&#13;
def foo1():&#13;
    pass&#13;
&#13;
@print_message('msg2')&#13;
def foo2():&#13;
    pass&#13;
&#13;
foo1() # msg1&#13;
foo2() # msg2&#13;
```&#13;
&#13;
装饰器可以嵌套，注意执行顺序是装饰器的使用顺序&#13;
&#13;
```python&#13;
def print_message(msg):&#13;
    def closeure(func):&#13;
        def wrap(*args, **kw):&#13;
            print(msg)&#13;
            return func(*args, **kw)&#13;
&#13;
        return wrap&#13;
&#13;
    return closeure&#13;
&#13;
@print_message('msg1')&#13;
@print_message('msg2')&#13;
def foo1():&#13;
    pass&#13;
&#13;
@print_message('msg2')&#13;
@print_message('msg1')&#13;
def foo2():&#13;
    pass&#13;
&#13;
foo1()&#13;
&#13;
# msg1&#13;
# msg2&#13;
&#13;
foo2()&#13;
&#13;
# msg2&#13;
# msg1&#13;
```&#13;
&#13;
因为装饰器实际上是语法糖，所以有一个问题，装饰器返回的函数并不是原本的函数，原本的函数的一些属性（如文档字符串）可能会丢失.&#13;
&#13;
解决方法是使用`functools.wraps`，它会将原来函数的属性复制到装饰器返回的函数中.&#13;
&#13;
```python&#13;
from functools import wraps&#13;
&#13;
def my_decorator(f):&#13;
    @wraps(f)&#13;
    def wrapper(*args, **kw):&#13;
        print('Calling decorated function')&#13;
        return f(*args, **kw)&#13;
&#13;
    return wrapper&#13;
&#13;
@my_decorator&#13;
def example():&#13;
    '''Docstring'''&#13;
    print('Called example function')&#13;
&#13;
example()  # Calling decorated functionCalled example function&#13;
example.__name__  # 'example'&#13;
example.__doc__  # 'Docstring'&#13;
```&#13;
。</description><guid isPermaLink="true">https://niyoh120.github.io/post/li-jie-Python-de-zhuang-shi-qi.html</guid><pubDate>Tue, 11 Jun 2024 07:58:52 +0000</pubDate></item></channel></rss>